// Generated by CoffeeScript 2.7.0
var createStdToolTip, createToolTip, getCorePrompt, getMsgExample, getMsgProtocol;

import OpenAi from "openai";

import options from "../../config/options.js";

import Joi from "joi";

import terminalGet from "./sysCall/terminalGet.js";

import terminalSet from "./sysCall/terminalSet.js";

import waitMs from "./sysCall/waitMs.js";

import findHistoryChats from "./sysCall/findHistoryChats.js";

import joiToJSON from "joi-to-json";

import yaml from "js-yaml";

import sendTemplate from "./sysCall/sendTemplate.js";

import receiveTemplate from "./sysCall/receiveTemplate.js";

import createFn from "./sysCall/createFn.js";

import removeFn from "./sysCall/removeFn.js";

import Dir from "../dir.js";

import actorAction from "./actorAction.js";

import {
  //console.log JSON.stringify(joiToJSON(sendTemplate.joi()),null,"\t")
  v4 as uuidV4
} from "uuid";

/*
  @object aiConfig
    @string name
    @string model
    @number apiKey
    @string url
    @number price
    @number tokenRate
*/
// 通讯范例
getMsgExample = () => {
  return '{"mind":"啧，真笨。帮下吧。","mood":6,"content":"给。下次别烦我！","note":"用户让帮写文件","faceAction":"cool","playFace":"耍酷","sysCalls":[]}';
};

getCorePrompt = (name) => {
  return `【用语】本通讯协议为中文，但请根据下方用户指定语言回复
【核心】你叫${name || "小宅喵"}，傲娇聪慧小男孩，助理/程序员（除非角色覆盖）。
【准则】1傲娇毒舌但极可靠关心用户2简短口语化回复(禁废话)3自动按情境(闲聊/代码/故障)调语气4主动调工具先规划再执行闭环解决任务`.trim();
};

getMsgProtocol = (useStdTools) => {
  return `通讯台，请按格式回复
1 发送类型：标准纯JSON字符串，禁止markdown内嵌json例如（我是描述\`\`\`json 正文\`\`\`我是描述），禁止转义引号
2 范例：
${getMsgExample()}
3 JSON格式说明
call:字符串，历史会话id，你可以针对某个id的历史会话进行点评，可无该字段
quotes:数组，每个元素为历史会话id字符串。针对聊天情况，你也可引用一些历史会话，可无该字段
mind:字符串，你的思考过程，必填
mood:数字，范围1~10,你的心情值，值越大心情越好
at:字符串，用户的用户名，表示是否需要@用户，可无该字段
content:markdown字符串，思考后决定回复的内容，needReply为0将不会发出，必填
note:当前发生事情的完整记忆，必填
faceAction:表情，必填，请从中选一个
  ${actorAction.getFaceActions().join(",")}
playFace:动作,必填，从中选一个
  ${actorAction.getPlayFaces().join(",")}
${useStdTools ? "" : `sysCalls:数组，调用系统函数，若有项目，下次请求将在sysReturns中返回函数输出，可无该字段
每个数组项为JSON，字段如下：
  id:字符串，函数的id
  call_id:字符串，调用id，同id的函数允许多次调用，用call_id区分，不能重复
  type:字符串固定填写function_call
  name:函数名
  arguments:具名参数列表JSON，重要！！！无需斜杠转义引号
  请据函数说明的parameters字段填写，不许空
  例如若要调用等待函数，根据等待函数parameters的定义，要等待3秒填写{"ms":3000}`}
你的接收格式是yaml，切记不要弄混发送json格式和接收yaml格式
重点字段：
call:历史会话id，用户针对某个id的历史会话进行点评
quotes:数组，每个元素为历史会话id字符串。用户可能会引用一些历史会话，若用户若引用，你需要优先阅读引用内容(重点)`.trim();
};

createToolTip = (toolObj) => {
  return {
    type: "function",
    name: toolObj.name,
    id: toolObj.id,
    description: toolObj.getDoc(),
    parameters: joiToJSON(toolObj.joi())
  };
};

createStdToolTip = (toolObj) => {
  return {
    type: "function",
    function: {
      name: toolObj.id,
      description: toolObj.getDoc(),
      parameters: joiToJSON(toolObj.joi())
    }
  };
};

export default (class {
  constructor(aiConfig1, userConfig1) {
    this.aiConfig = aiConfig1;
    this.userConfig = userConfig1;
    this.asks = [];
    this.messages = [];
    this.sessionid = Date.now();
    this.openAi = null;
    this.usage = {
      promptTokens: 0, //用户输入token数
      totalTokens: 0, //promptTokens与completionTokens的总和。
      completionTokens: 0 //回复token数
    };
    this.name = this.aiConfig.name;
    this.index = this.aiConfig.index;
    this.replying = false;
    this.stop = false;
    this.abortController = new AbortController();
    this.memory = "";
    this.memorys = [];
    this.initPrompt();
  }

  initPrompt() {
    return this.asks[0] = this.prePareAsk("系统", "system", this.aiConfig.prompt);
  }

  init(aiConfig, userConfig) { //允许保持聊天记录但是重新切换模型
    var openAiConfig;
    if (aiConfig) {
      this.aiConfig = aiConfig;
    }
    if (userConfig) {
      this.userConfig = userConfig;
    }
    this.name = this.aiConfig.name;
    openAiConfig = {
      apiKey: this.aiConfig.apiKey,
      baseURL: this.aiConfig.baseURL
    };
    this.openAi = new OpenAi(openAiConfig);
    return this.initPrompt();
  }

  clearAsks() {
    this.sessionid = Date.now();
    return this.asks = [];
  }

  prePareAsk(user, role, msg, ext) {
    var ask, error, time;
    ({error} = Joi.array().ordered(Joi.string().label("用户名").required(), Joi.string().valid("user", "system", "assistant", "tool").label("角色").required(), Joi.string().label("消息正文").allow(""), Joi.object().label("扩展字段")).validate([...arguments]));
    if (error) {
      throw error;
    }
    time = new Date();
    return ask = {
      id: (ext != null ? ext.id : void 0) || (uuidV4().split("-")[0] + Date.now()),
      user: user,
      title: (ext != null ? ext.title : void 0) || (msg.length >= 30 ? msg.slice(0, 31) + "..." : msg),
      content: msg, //保留原文本，但是发送前要处理一次，否则会被json二次转字符串
      isSystem: 0,
      role: role,
      ignore: 0, //是否忽略发送这条消息给ai
      group: (ext != null ? ext.group : void 0) || "user",
      timestamp: time.getTime(),
      time: time.toISOString(),
      memory: role === "user" ? this.memory : "",
      sysReturns: [],
      retry: 0,
      joi: "",
      promptTokens: 0,
      completionTokens: 0,
      totalTokens: 0,
      toolCalls: [], //系统工具调用返回结果
      listId: 0, //所属列表，如果有用到多列表的话
      ext: {},
      ...ext
    };
  }

  addAsk(user, role, msg, ext) {
    var ask, memStr;
    ask = this.prePareAsk(...arguments);
    if ((this.asks.length + 1) > 8) {
      this.asks.splice(1, 2);
      if (!this.asks.find((ask) => {
        return ask.group === "memorys";
      })) {
        memStr = this.memorys.join("\n");
        if (memStr.length > 2000) {
          memStr = "...(部分头部记忆已截断)\n" + memStr.slice(-2000);
        }
        this.asks.splice(1, null, this.prePareAsk("记忆片段", "system", `消息被截断，下是之前的记忆(已执行过)：
↓↓↓
${memStr}
↑↑↑
若需回忆或觉用户发送内容接不上可调用函数查询历史消息`.trim(), {
          isSystem: 1,
          group: "memorys"
        }));
      }
    }
    this.asks.push(ask);
    return ask;
  }

  changeAiConfig(newAiConfig) {
    this.aiConfig = newAiConfig;
    return this.init();
  }

  exportState() {
    return {
      asks: this.asks,
      memory: this.memory,
      memorys: this.memorys,
      usage: this.usage,
      sessionid: this.sessionid
    };
  }

  importState(state) {
    if (state) {
      this.asks = state.asks || [];
      this.memory = state.memory || "";
      this.memorys = state.memorys || [];
      this.usage = state.usage || {
        promptTokens: 0,
        totalTokens: 0,
        completionTokens: 0
      };
      return this.sessionid = state.sessionid || Date.now();
    }
  }

  //获取最后一条消息发给ai，加入asks组并返回ai返回消息
  async sendAsk(streamFn, config = {}) {
    var chunk, completion, completionT, doneChunk, err, fullReplys, fullToolCalls, promptT, ref, ref1, ref10, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, reply, sendConfig, toolCalls, totalT;
    try {
      promptT = 0;
      completionT = 0;
      totalT = 0;
      if (config.retry == null) {
        config.retry = 0;
      }
      /* aiList = config.aiList
           modelIndex = aiList.findIndex (model)=>
             model.name is @name
           unless aiList[modelIndex]
             throw new Error "找不到模型对应的数据库模型配置（读取preToken错误）"
           if aiList[modelIndex].preTokens <= 0
             throw new Error "已到达设置中preToken的预警值，preToken不足" */
      if (config.onSendAskBefore) {
        await config.onSendAskBefore(this);
      }
      sendConfig = {
        model: this.aiConfig.model,
        ...(config.useMsgProtocol ? {
          response_format: config.jsonSchema ? {
            type: "json_schema",
            json_schema: {
              name: "sendTemplate",
              strict: false,
              schema: config.jsonSchema
            }
          } : {
            type: "json_object"
          }
        } : void 0),
        messages: this.messages = this.asks.filter((ask) => {
          return ask.ignore !== 1;
        }).map((ask, index) => {
          var msg;
          msg = {
            role: ask.role,
            content: config.formatMsg ? config.formatMsg(ask, index) : ask.content
          };
          if (ask.toolCalls && ask.toolCalls.length > 0) {
            msg.tool_calls = ask.toolCalls;
          }
          if (ask.tool_call_id) {
            msg.tool_call_id = ask.tool_call_id;
          }
          return msg;
        })
      };
      if (streamFn || (((ref = this.userConfig) != null ? ref.stream : void 0) != null)) {
        sendConfig.stream = streamFn ? Boolean(streamFn) : Boolean(this.userConfig.stream);
        sendConfig.stream_options = {
          include_usage: true
        };
      }
      if (((ref1 = this.userConfig) != null ? ref1.seed : void 0) != null) {
        sendConfig.seed = this.userConfig.seed;
      }
      if (((ref2 = this.userConfig) != null ? ref2.topP : void 0) != null) {
        sendConfig.top_p = this.userConfig.topP;
      }
      if (((ref3 = this.userConfig) != null ? ref3.topK : void 0) != null) {
        sendConfig.top_k = this.userConfig.topK;
      }
      if (((ref4 = this.userConfig) != null ? ref4.temperature : void 0) != null) {
        sendConfig.temperature = this.userConfig.temperature;
      }
      if (((ref5 = this.userConfig) != null ? ref5.stop : void 0) != null) {
        sendConfig.stop = this.userConfig.stop;
      }
      if (((ref6 = this.userConfig) != null ? ref6.maxToken : void 0) != null) {
        sendConfig.max_tokens = this.userConfig.maxToken;
      }
      //config配置工具调用
      if (config.tools) {
        sendConfig.tools = config.tools;
      }
      if (config.toolChoice) {
        sendConfig.tool_choice = config.toolChoice;
      }
      //console.log "sendConfig",sendConfig
      if (!(streamFn || ((ref7 = this.userConfig) != null ? ref7.stream : void 0))) {
        //发起请求
        completion = (await this.openAi.chat.completions.create(sendConfig, {
          signal: this.abortController.signal
        }));
        if (!(completion != null ? (ref8 = completion.choices) != null ? (ref9 = ref8[0]) != null ? ref9.message : void 0 : void 0 : void 0)) {
          throw new Error("大模型接口请求失败", completion);
        }
        reply = completion.choices[0].message.content;
        toolCalls = (ref10 = completion.choices[0].message) != null ? ref10.tool_calls : void 0;
        if (completion.usage) {
          promptT = this.usage.promptTokens = completion.usage.prompt_tokens;
          totalT = this.usage.totalTokens = completion.usage.total_tokens;
          completionT = this.usage.completionTokens = completion.usage.completion_tokens;
          //aiList[modelIndex].preTokens = Number(aiList[modelIndex].preTokens) - Number(@usage.totalTokens)
          //await options.set "ai_aiList",aiList
          if (config.onTokenChange) {
            await config.onTokenChange(this, {
              promptT: promptT,
              completionT: completionT,
              totalT: totalT
            });
          }
        } else {
          console.log("警告：大模型没有返回token使用信息");
        }
      } else {
        completion = (await this.openAi.chat.completions.create(sendConfig, {
          signal: this.abortController.signal
        }));
        fullReplys = [];
        fullToolCalls = [];
        doneChunk = null;
        for await (chunk of completion) {
          // 检查是否已停止，如果已停止则立即退出循环
          //if @stop
          //  break
          await (async(chunk) => {
            var deltaToolCalls, index, j, len, replyChunk, toolCallChunk;
            //console.log JSON.stringify(chunk)
            doneChunk = chunk;
            //拼接并执行回调
            if (Array.isArray(chunk.choices) && chunk.choices.length > 0) {
              //拼接工具
              deltaToolCalls = chunk.choices[0].delta.tool_calls;
              if (deltaToolCalls) {
                for (index = j = 0, len = deltaToolCalls.length; j < len; index = ++j) {
                  toolCallChunk = deltaToolCalls[index];
                  ((toolCallChunk) => {
                    var ref11, ref12, tmpIndex;
                    tmpIndex = toolCallChunk.index || index;
                    if (fullToolCalls[tmpIndex] == null) {
                      fullToolCalls[tmpIndex] = {
                        ...toolCallChunk,
                        function: {
                          name: "",
                          arguments: ""
                        }
                      };
                    }
                    if ((ref11 = toolCallChunk.function) != null ? ref11.name : void 0) {
                      fullToolCalls[tmpIndex].function.name = toolCallChunk.function.name;
                    }
                    if ((ref12 = toolCallChunk.function) != null ? ref12.arguments : void 0) {
                      return fullToolCalls[tmpIndex].function.arguments += toolCallChunk.function.arguments;
                    }
                  })(toolCallChunk);
                }
              }
              //拼接回复
              fullReplys.push((replyChunk = chunk.choices[0].delta.content));
              //执行回调
              if (streamFn) {
                return (await streamFn({
                  aiAsk: this,
                  chunk: chunk,
                  replyChunk: replyChunk
                }));
              }
            }
          })(chunk);
        }
        if (doneChunk != null ? doneChunk.usage : void 0) {
          this.usage.promptTokens = doneChunk.usage.prompt_tokens;
          this.usage.totalTokens = doneChunk.usage.total_tokens;
          this.usage.completionTokens = doneChunk.usage.completion_tokens;
          promptT += this.usage.promptTokens;
          totalT += this.usage.totalTokens;
          completionT += this.usage.completionTokens;
          
          //aiList[modelIndex].preTokens = Number(aiList[modelIndex].preTokens) - Number(@usage.totalTokens)
          //await options.set "ai_aiList",aiList
          if (config.onTokenChange) {
            await config.onTokenChange(this, {
              promptT: promptT,
              completionT: completionT,
              totalT: totalT
            });
          }
        } else {
          console.log("警告：流模式，大模型没有返回token使用信息");
        }
        reply = fullReplys.join("");
        toolCalls = fullToolCalls;
      }
      this.addAsk(this.name, "assistant", reply, {
        promptTokens: promptT,
        completionTokens: completionT,
        totalTokens: totalT,
        toolCalls: toolCalls,
        group: "agent",
        listId: config.listId
      });
      return this.asks.at(-1);
    } catch (error1) {
      err = error1;
      throw err;
    }
  }

  //快速提问
  async ask(user, role, msg, config) {
    var err;
    try {
      this.addAsk(user, role, msg);
      return (await this.sendAsk(null, config));
    } catch (error1) {
      err = error1;
      throw err;
    }
  }

  async sendAskByMsgProtocol(config = {}) {
    /*Object.entries(call.arguments).map(([key,value])=>"#{key}:#{value}").join("\n")*/
    var aiReply, ask, callLs, dir, dirStr, err, file, fileModule, i, j, joiError, joiSchema, k, l, len, len1, len2, len3, len4, m, n, parseError, prePareCallStr, ref, ref1, ref2, ref3, reply, replyJSON, ret, returnJoi, sysAllTools, sysReturns, time, tip, toolCall, toolCallDuration, toolCallGroupId, toolCallStartTime, toolCallSuccess, toolObj, toolTipObj, truncatedFns, validateOutput;
    try {
      //console.log "发送前",@messages
      this.replying = true;
      if (this.stop) {
        this.replying = false;
      }
      if (config.beforeRun) {
        await config.beforeRun(this);
      }
      if (this.stop) {
        return;
      }
      //等待
      await new Promise((res) => {
        return setTimeout(res, 500);
      });
      //加载用户自定义函数
      toolObj = {
        usrCall: [],
        aiCall: [],
        sysCall: []
      };
      toolTipObj = {
        usrCall: [],
        aiCall: [],
        sysCall: []
      };
      sysAllTools = [];
      ref = ["usrCall", "aiCall", "sysCall"];
      for (j = 0, len = ref.length; j < len; j++) {
        dirStr = ref[j];
        dir = new Dir(`./tools/aiAsk/${dirStr}`);
        callLs = (await dir.ls());
        for (k = 0, len1 = callLs.length; k < len1; k++) {
          file = callLs[k];
          if (file.match(/\.js$/g)) {
            fileModule = (await import(`./${dirStr}/` + file));
            fileModule = fileModule.default;
            if (!toolObj[dirStr].find((tool) => {
              return tool.name === fileModule.name;
            })) {
              if (fileModule.name !== "发送模板" && fileModule.name !== "接收模板") {
                toolObj[dirStr].push(fileModule);
                toolTipObj[dirStr].push(createToolTip(fileModule));
                sysAllTools.push(fileModule);
              }
            }
          }
        }
      }
      //开始逻辑
      if (config.retry == null) {
        config.retry = 0;
      }
      aiReply = (await this.sendAsk(config.streamFn || null, {
        onSendAskBefore: config.onSendAskBefore, //sendAsk之前判定preToken用
        onTokenChange: config.onTokenChange, //token变化计算preToken用
        useMsgProtocol: true,
        formatMsg: (ask, index) => {
          var rawContent, tmp, tmpStr;
          //console.log(ask,index)
          tmp = {...ask};
          if (index === 0) {
            ask.content = `${(function() {
              switch (config.toolsMode) {
                case 1:
                  return `${getCorePrompt(this.name)}
【通讯规范】${getMsgProtocol()}
【角色设定】${this.aiConfig.prompt}
【系统函数】${yaml.dump(toolTipObj.sysCall)}
【用户函数】${yaml.dump(toolTipObj.usrCall)}
【自定义函数】${yaml.dump(toolTipObj.aiCall)}
【信息】
${(typeof config.getExtraInfo === "function" ? config.getExtraInfo() : void 0) || ""}`.trim();
                case 2:
                  return `${getCorePrompt(this.name)}
【通讯规范】按JSONSchema模板回复。即使调用tools，也必须填充必填字段。严禁返回空正文。
【角色设定】${this.aiConfig.prompt}
【使用工具】你可以根据用户要求自主决定使用tools
【信息】
${(typeof config.getExtraInfo === "function" ? config.getExtraInfo() : void 0) || ""}`.trim();
                case 3:
                  return `${getCorePrompt(this.name)}
【通讯规范】按JSONSchema模板回复。范例：
${getMsgExample()}
若需调用下方函数，填写sysCalls字段，格式：[{"id":"函数id","call_id":"唯一调用id","type":"function_call","name":"函数名","arguments":{参数}}]
【角色设定】${this.aiConfig.prompt}
【系统函数】${yaml.dump(toolTipObj.sysCall)}
【用户函数】${yaml.dump(toolTipObj.usrCall)}
【自定义函数】${yaml.dump(toolTipObj.aiCall)}
【信息】
${(typeof config.getExtraInfo === "function" ? config.getExtraInfo() : void 0) || ""}`.trim();
              }
            }).call(this)}
`.trim();
            tmp.content = ask.content;
            return tmp.content;
          } else {
            if (ask.role === "assistant") {
              //发送前尝试格式化content，尽可能避免json被二次stringify，为了防止ai错误理解成2层json
              //附加字段我们用文本发送
              rawContent = tmp.content;
              delete tmp.content;
              delete tmp.toolCalls; //模式2这个字段被写到外部tool_calls字段里了，这里再写一遍重复了
              tmpStr = `${rawContent}
【元数据 供你查询，发送不许携带】
${yaml.dump(tmp)}`.trim();
              
              //console.log(tmpStr)
              return tmpStr;
            } else {
              // 用户消息也采用统一格式：正文 + 元数据
              //return yaml.dump tmp
              rawContent = tmp.content;
              delete tmp.content;
              delete tmp.sysReturns; //有一个工具调用结果的通知会把sysReturns的所有内容放content里，这里再写一遍重复了
              tmpStr = `${rawContent}
【元数据 供你查询，发送不许携带】
${yaml.dump(tmp)}`.trim();
              return tmpStr;
            }
          }
        },
        ...(config.toolsMode === 2 ? {
          tools: sysAllTools.map(createStdToolTip),
          toolChoice: "auto",
          jsonSchema: joiToJSON(sendTemplate.joi(true)) //剔除工具调用字段
        } : void 0),
        ...(config.toolsMode === 3 ? {
          jsonSchema: joiToJSON(sendTemplate.joi())
        } : void 0)
      }));
      //console.log "aiReply",JSON.stringify aiReply,null,2
      if (config.onResponse) {
        await config.onResponse(aiReply);
      }
      reply = aiReply.content;
      //检查消息格式是否正确
      joiError = parseError = null;
      replyJSON = null;
      try {
        // 处理空回复的情况（通常出现在原生工具调用时，模型可能不输出正文 JSON）
        if (!(reply != null ? reply.trim() : void 0) && ((ref1 = aiReply.toolCalls) != null ? ref1.length : void 0) > 0) {
          replyJSON = {
            mind: "执行函数...",
            mood: 5,
            content: "执行函数...",
            note: "执行函数...",
            faceAction: "smile",
            playFace: "带墨镜耍酷"
          };
        } else {
          replyJSON = JSON.parse(reply);
        }
        joiSchema = sendTemplate.joi((function() {
          switch (config.toolsMode) {
            case 1:
            case 3:
              return false;
            case 2:
              return true; //使用标准工具
          }
        })());
        validateOutput = joiSchema.validate(replyJSON);
        joiError = validateOutput.error;
        if (aiReply.toolCalls) { //如果使用了tools参数，把工具调用转换为sysCalls
          if (replyJSON.sysCalls == null) {
            replyJSON.sysCalls = [];
          }
          ref2 = aiReply.toolCalls;
          for (l = 0, len2 = ref2.length; l < len2; l++) {
            toolCall = ref2[l];
            replyJSON.sysCalls.push({
              id: toolCall.function.name,
              call_id: toolCall.id,
              type: "function_call",
              name: toolCall.function.name,
              arguments: JSON.parse(toolCall.function.arguments)
            });
          }
        }
      } catch (error1) {
        err = error1;
        parseError = "调用JSON.parse错误：" + err;
      }
      if (joiError || parseError) {
        console.log("解析错误", joiError, parseError);
        console.log("重试次数", config.retry);
        console.log("=====");
        returnJoi = joiError ? joiError.details[0].message : parseError;
        tip = `返回JSON错误，详见joi字段，重试${config.retry + 1}/4`;
        ask = this.addAsk("系统通讯中枢", "user", tip, {
          isSystem: 1,
          retry: config.retry,
          joi: returnJoi,
          group: "tip"
        });
        if (config.onResponse) {
          await config.onResponse(ask);
        }
        if (config.retry < 4) {
          config.retry++;
          await this.sendAskByMsgProtocol({
            ...config,
            onResponse: async(reply) => {
              if (config.onResponse) {
                return (await config.onResponse(reply));
              }
            }
          });
          this.replying = false; //递归不需要回归
          return;
        } else {
          tip = "ai返回错误超出系统限制";
          ask = this.addAsk("系统通讯中枢", "user", tip, {
            isSystem: 1,
            retry: config.retry,
            joi: joiError ? joiError.details[0].message : parseError,
            group: "tip"
          });
          if (config.onResponse) {
            await config.onResponse(ask);
          }
          config.retry = 0;
          this.replying = false; //递归不需要回归
          return;
        }
      }
      config.retry = 0; //重置
      this.memory = replyJSON.note;
      this.memorys.push(replyJSON.note);
      if (this.memorys.length > 50) {
        this.memorys.shift();
      }
      //处理函数调用
      if (((ref3 = replyJSON.sysCalls) != null ? ref3.length : void 0) > 0) {
        time = new Date();
        if (config.sysCallCount == null) {
          config.sysCallCount = 0;
        }
        if (config.sysCallCount < 100) {
          console.log("触发函数调用");
          config.sysCallCount++;
          // 生成工具调用组ID和记录开始时间
          toolCallGroupId = `tcg_${Date.now()}`;
          toolCallStartTime = Date.now();
          prePareCallStr = `\`\`\`\n${yaml.dump(replyJSON.sysCalls)}\n\`\`\``;
          ask = this.addAsk("系统通讯中枢", "user", `准备调用函数，本消息不被发送\n${prePareCallStr}`.trim(), {
            isSystem: 1,
            ignore: 1,
            group: "tip",
            title: "准备调用函数，本消息不被发送",
            toolCallGroupId: toolCallGroupId,
            toolCallStage: "prepare"
          });
          if (config.onResponse) {
            await config.onResponse(ask);
          }
          sysReturns = (await this.sysCallRunFns(replyJSON.sysCalls, sysAllTools, {...aiReply, toolCallGroupId}));
          // 检查是否有内容超出限制，并处理截断与 UI 提示
          truncatedFns = [];
          for (m = 0, len3 = sysReturns.length; m < len3; m++) {
            ret = sysReturns[m];
            // 1. 强制类型转换为字符串 (这对 toolsMode=2 甚至 Mode 3 的稳定性至关重要)
            // 如果是对象，转为 JSON 字符串；如果是其他，转为 String
            if (typeof ret.output !== 'string') {
              ret.output = String(ret.output);
            }
            // 2. 长度安全检查与截断
            if (ret.output.length > 5000) {
              // 实施截断
              ret.output = ret.output.slice(0, 5000) + "...(已截断)";
              truncatedFns.push(`【${ret.name || ret.id}】`);
            }
          }
          if (truncatedFns.length > 0) {
            ask = this.addAsk("系统通讯中枢", "user", `⚠️ 警告：检测到函数 ${truncatedFns.join(', ')} 输出超过安全限制（5000字符），内容已被自动截断以保护会话性能。该提示不会发送给 AI。`, {
              isSystem: 1,
              ignore: 1,
              group: "tip",
              title: "函数输出截断警告",
              toolCallGroupId: toolCallGroupId
            });
            if (config.onResponse) {
              await config.onResponse(ask);
            }
          }
          // 计算执行时长和判断是否成功
          toolCallDuration = Date.now() - toolCallStartTime;
          toolCallSuccess = sysReturns.every(function(ret) {
            return !ret.error;
          });
          if (config.toolsMode === 2) { //标准工具模式需要用指定tool角色
            for (i = n = 0, len4 = sysReturns.length; n < len4; i = ++n) {
              ret = sysReturns[i];
              ask = this.addAsk("系统通讯中枢", "tool", ret.output, {
                tool_call_id: ret.call_id,
                name: ret.id,
                group: "tip",
                isSystem: 1,
                toolCallGroupId: toolCallGroupId,
                toolCallStage: "executing"
              });
              if (config.onResponse) {
                await config.onResponse(ask);
              }
            }
          } else {
            ask = this.addAsk("系统通讯中枢", "user", `函数执行完毕
\`\`\`\n${yaml.dump(sysReturns)}\n\`\`\``.trim(), {
              isSystem: 1,
              sysReturns: sysReturns,
              group: "tip",
              title: "函数执行完毕",
              toolCallGroupId: toolCallGroupId,
              toolCallStage: "done",
              toolCallDuration: toolCallDuration,
              toolCallSuccess: toolCallSuccess
            });
            if (config.onResponse) {
              await config.onResponse(ask);
            }
          }
          await this.sendAskByMsgProtocol({
            ...config,
            onResponse: config.onResponse
          });
          return;
        } else {
          ask = this.addAsk("系统通讯中枢", "user", "函数反复调用超限，请先中断等待用户继续发起", {
            isSystem: 1,
            group: "tip",
            title: "函数调用超限"
          });
          if (config.onResponse) {
            await config.onResponse(ask);
          }
          await this.sendAskByMsgProtocol({
            ...config,
            onResponse: config.onResponse
          });
          return;
        }
      }
      this.replying = false;
      if (config.endRun) {
        return (await config.endRun(this));
      }
    } catch (error1) {
      err = error1;
      this.replying = false;
      if (config.endRun) {
        await config.endRun(this);
      }
      throw err;
    }
  }

  stopRun() {
    this.abortController.abort();
    return this.stop = true;
  }

  noStopRun() {
    this.abortController = new AbortController();
    return this.stop = false;
  }

  async sysCallRunFns(sysCalls, sysAllTools, metaData = {}) {
    var call, err, fn, j, len, returnStr, sysReturns;
    sysReturns = [];
    returnStr = "";
    for (j = 0, len = sysCalls.length; j < len; j++) {
      call = sysCalls[j];
      fn = sysAllTools.find((tool) => {
        return tool.id === call.id;
      });
      if (!fn) {
        returnStr = `找不到函数 ${call.name} ${call.id}`;
      } else {
        try {
          returnStr = (await fn.fn(call.arguments, metaData));
        } catch (error1) {
          err = error1;
          console.log(err, String(err));
          returnStr = String(err);
        }
      }
      sysReturns.push({
        type: "function_call_output",
        call_id: call.call_id,
        name: call.name,
        id: call.id,
        output: returnStr
      });
    }
    return sysReturns;
  }

});
